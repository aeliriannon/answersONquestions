Что такое цикл событий (event loop)? В чём разница между стеком вызовов (call stack) и очередью событий (callback queue)?
=====================

**Event Loop**  — это механизм в JavaScript, который контролирует порядок выполнения событий и обеспечивает отзывчивость и неблокирующую работу в среде однопоточного выполнения.

Представь, что у тебя есть очередь событий и стопка карточек. Когда происходит событие, например, клик мыши или загрузка файла, эта информация добавляется в очередь событий. Затем цикл событий (event loop) проверяет, есть ли что-то в очереди событий. Если очередь не пуста, он берет первое событие из очереди и обрабатывает его.

Теперь представь, что на каждой карточке есть инструкции о том, что нужно сделать. Цикл событий (event loop) берет первое событие из очереди и смотрит на инструкции на карточке. Он добавляет инструкции в стек вызовов (call stack), который является специальной структурой данных для выполнения кода.

Стек вызовов (call stack) можно представить как стопку тарелок. Когда цикл событий (event loop) добавляет инструкции в стек вызовов, они выполняются по очереди, начиная с верхней тарелки стека. Когда инструкция выполняется, она удаляется из стека.

Теперь представь, что инструкция на карточке говорит циклу событий (event loop) ожидать какое-то время или выполнить определенную задачу, когда выполняются определенные условия. Вместо того, чтобы останавливать выполнение и занимать время, цикл событий (event loop) переносит эту инструкцию в другую очередь, называемую очередью событий (callback queue). Очередь событий (callback queue) содержит функции (колбэки), которые должны быть вызваны, когда событие произойдет или определенное время истечет.

Цикл событий (event loop) постоянно проверяет стек вызовов (call stack) и очередь событий (callback queue). Если стек вызовов (call stack) пуст и очередь событий (callback queue) не пуста, цикл событий (event loop) берет первую функцию из очереди событий (callback queue) и добавляет ее в стек вызовов (call stack) для выполнения.

Таким образом, цикл событий (event loop) управляет порядком выполнения событий и позволяет JavaScript быть отзывчивым и неблокирующим. Он работает следующим образом:

* Цикл событий (event loop) проверяет, есть ли функции в очереди событий (callback queue).
* Если очередь событий не пуста, цикл событий берет первую функцию из очереди и помещает ее в стек вызовов (call stack) для выполнения.
* Функция выполняется в стеке вызовов, и если внутри нее есть асинхронные операции, они передаются в соответствующие веб-интерфейсы (Web APIs) для выполнения в фоновом режиме.
* Пока асинхронные операции выполняются, цикл событий продолжает проверять стек вызовов и очередь событий.
* Когда асинхронная операция завершается, соответствующий колбэк помещается в очередь событий.
* Когда стек вызовов становится пустым, цикл событий берет следующий колбэк из очереди и помещает его в стек вызовов для выполнения.
* Этот процесс повторяется, пока все функции в очереди событий не будут выполнены.

Такой подход позволяет JavaScript выполнять асинхронные операции без блокировки основного потока выполнения. Это позволяет отзывчиво реагировать на пользовательские действия, загружать данные с сервера, выполнять анимации и многое другое, не прерывая основной поток выполнения.


**Call Stack (стек вызовов):** Стек вызовов является структурой данных, которая отслеживает порядок выполнения функций в JavaScript. Когда функция вызывается, она добавляется в вершину стека. Когда функция завершает свою работу, она удаляется из вершины стека. Это позволяет JavaScript выполнять код последовательно и возвращаться к предыдущим вызовам функций.

**Event Queue (очередь событий):** Очередь событий - это структура данных, которая содержит колбэк-функции (задачи), которые должны быть выполнены в определенном порядке. Когда происходит событие, такое как клик мыши или завершение асинхронной операции, соответствующий колбэк помещается в очередь событий. Очередь событий ожидает, пока стек вызовов станет пустым, а затем перемещает колбэк из очереди в стек вызовов для выполнения.

**Event Loop (цикл событий):** Цикл событий - это механизм, который постоянно проверяет состояние стека вызовов и очереди событий. Когда стек вызовов пуст, а очередь событий содержит колбэк, цикл событий берет следующий колбэк из очереди и помещает его в стек вызовов для выполнения. Это позволяет JavaScript обрабатывать события и задачи асинхронно, сохраняя отзывчивость интерфейса.

**Web APIs (веб-интерфейсы):** Веб-интерфейсы предоставляются браузером и предоставляют средства для выполнения асинхронных операций, таких как запросы AJAX, таймеры и манипуляции с DOM. Когда веб-интерфейс выполняет операцию, например, загрузку изображения, он добавляет соответствующий колбэк в очередь событий для дальнейшего выполнения.


Примеры вопросов/задач
=====================

* Что произойдет, если функция в цикле событий выполняется долго и блокирует основной поток выполнения?(**Если функция в цикле событий выполняется долго и блокирует основной поток выполнения, то это может привести к задержкам в отзывчивости интерфейса. Все другие функции в очереди событий будут ждать, пока долгая функция не завершится.**)
* Что такое Web APIs и как они связаны с циклом событий?(**Web APIs - это набор веб-интерфейсов, предоставляемых браузером, таких как таймеры, AJAX-запросы, работа с файлами и другие. Они связаны с циклом событий тем, что асинхронные операции, использующие эти веб-интерфейсы, передаются им для выполнения в фоновом режиме, позволяя основному потоку выполнения оставаться свободным.**)
* Какой порядок выполнения функций в цикле событий, если есть исходящий запрос на сервер и обработчик события клика?(**Порядок выполнения функций в цикле событий зависит от их типа и наличия асинхронных операций. Обработчики событий выполняются, когда происходит соответствующее событие. Исходящие запросы на сервер обычно выполняются асинхронно, в то время как остальные функции выполняются синхронно по мере поступления в очередь.**)
* Как работает setTimeout() в контексте цикла событий?(**setTimeout() используется для установки задержки перед выполнением функции. Когда вызывается setTimeout(), функция помещается в очередь событий с указанной задержкой. По истечении заданного времени, функция перемещается в стек вызовов и выполняется.**)
* Что произойдет, если веб-интерфейс добавляет функцию в очередь событий, но стек вызовов уже заполнен?(**Если веб-интерфейс добавляет функцию в очередь событий, но стек вызовов уже заполнен, то новая функция будет ожидать, пока стек не освободится. Это может привести к задержкам в выполнении функций и снижению отзывчивости интерфейса**)
* Какой порядок выполнения функций, если есть таймер, асинхронный запрос и колбэк по завершению анимации?(**Порядок выполнения функций зависит от их типа и событий, происходящих в браузере. Таймер будет выполнен после указанной задержки, асинхронный запрос выполнится по завершении и получении ответа, а колбэк по завершению анимации будет вызван после окончания анимации.**)


* Что выведет консоль?

```setTimeout(() => {
    console.log(1);
}, 0);

console.log(2);

**//2 //1**
```
    ** Любой асинхронный код сработает позже синхронного, т.к. асинхронный код сначала попадает в web Api а только затем попадает в очередь callback queue. Тогда как синхронный код попадает в очередь сразу и оттуда в call stack на выполнение

    ** А так же, в JS к любому таймауту добавляется 4 милисекуды, даже если задержка 0, то она все равно будет, хоть и маленькая

* Напишите код, который добавляет функцию в очередь событий после задержки в 2 секунды.

```
setTimeout(function() {
  console.log('Функция выполнена после задержки в 2 секунды');
}, 2000);
```
* Напишите код, который выполняет две асинхронные операции одновременно и выводит результат, когда оба запроса завершены.
```
const promise1 = fetch('https://api.example.com/data1');
const promise2 = fetch('https://api.example.com/data2');

Promise.all([promise1, promise2])
  .then(([response1, response2]) => {
    console.log('Оба запроса завершены');
    // Дополнительная обработка данных
  })
  .catch(error => {
    console.error('Произошла ошибка', error);
  });
```
* Напишите код, который использует Promise и цикл событий для выполнения двух асинхронных операций последовательно.
```
function asyncOperation1(callback) {
  setTimeout(() => {
    console.log('Асинхронная операция 1 завершена');
    callback();
  }, 2000);
}

function asyncOperation2(callback) {
  setTimeout(() => {
    console.log('Асинхронная операция 2 завершена');
    callback();
  }, 1000);
}

function finalCallback() {
  console.log('Обе асинхронные операции выполнены последовательно');
}

asyncOperation1(() => {
  asyncOperation2(finalCallback);
});
```
* Напишите код, который выполняет функцию каждую секунду, пока пользователь не нажмет кнопку "Остановить".

```
let intervalId;

function performAction() {
  console.log('Выполняю действие каждую секунду');
}

function stopAction() {
  clearInterval(intervalId);
  console.log('Действие остановлено');
}

intervalId = setInterval(performAction, 1000);
```
