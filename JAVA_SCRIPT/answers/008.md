Что такое замыкание (closure) и какие существуют сценарии его использования?
=====================

**Замыкание (closure)** - это особенность в JavaScript, которая позволяет функции запоминать и получать доступ к переменным из внешней области видимости, даже после того, как эта функция была выполнена.

Давай представим, что у тебя есть ящик с игрушками. Когда ты открываешь ящик и берешь игрушку, она остается у тебя в руках, даже если ящик закрывается. Замыкание работает подобным образом - функция **"запоминает"** переменные из внешней области видимости, и эти переменные остаются доступными для функции, даже после того, как она завершает свою работу.

**Сценарии использования замыканий включают:**

* **Сохранение приватных данных:** Замыкания позволяют создавать приватные переменные и функции. Это полезно, когда ты хочешь скрыть определенные данные от внешнего доступа и предоставить доступ только через публичные методы.

* **Работа с функциями обратного вызова (callback):** Замыкания позволяют передавать функции их контекст, включая переменные, необходимые для выполнения операции в будущем. Это особенно полезно в асинхронном программировании.

* **Модульный паттерн:** Замыкания могут быть использованы для создания модулей - независимых блоков кода, которые инкапсулируют данные и функциональность. Это помогает в организации и структурировании кода.

* **Итерации и циклы:** Замыкания позволяют сохранять состояние переменных внутри циклов или итераций, даже после завершения каждой итерации.

**Простой пример замыкания:**

```
function counter() {
  let count = 0;

  function increment() {
    count++;
    console.log(count);
  }

  return increment;
}

const myCounter = counter();
myCounter(); // Выводит 1
myCounter(); // Выводит 2
myCounter(); // Выводит 3

```

В этом примере функция counter создает переменную count и возвращает функцию increment, которая увеличивает значение count при каждом вызове и выводит его в консоль. Переменная count сохраняется благодаря замыканию, и каждый раз, когда мы вызываем myCounter, она продолжает увеличиваться и выводить новое значение.

Примеры вопросов/задач
=====================

* Что такое замыкание в JavaScript? (**Замыкание - это особенность в JavaScript, которая позволяет функции запоминать и получать доступ к переменным из внешней области видимости, даже после того, как эта функция была выполнена.**) 

* Какое значение будет выведено в консоль?
```
function outer() {
  let outerVar = 'I am outside!';

  function inner() {
    console.log(outerVar);
  }

  return inner;
}

const closureExample = outer();
closureExample();

```
(**В консоль будет выведено "I am outside!". Функция inner имеет доступ к переменной outerVar из внешней области видимости, благодаря замыканию.**)


* Создайте функцию multiplyBy с использованием замыкания, которая принимает один аргумент и возвращает функцию, которая умножает свой аргумент на значение, переданное в multiplyBy.
```
function multiplyBy(factor) {
  return function (number) {
    return number * factor;
  };
}

const multiplyByTwo = multiplyBy(2);
console.log(multiplyByTwo(5)); // Выводит 10
console.log(multiplyByTwo(10)); // Выводит 20
```

* Создайте счетчик, используя замыкание. Функция counter должна возвращать объект с методами increment и decrement, которые увеличивают и уменьшают счетчик соответственно.

```
function counter() {
  let count = 0;

  return {
    increment: function () {
      count++;
    },
    decrement: function () {
      count--;
    },
    getCount: function () {
      return count;
    }
  };
}

const myCounter = counter();
myCounter.increment();
myCounter.increment();
myCounter.decrement();
console.log(myCounter.getCount()); // Выводит 1
```

* Напишите функцию createLogger, которая создает простой логгер с использованием замыкания. Логгер должен иметь методы log, printLogs и clearLogs. Метод log принимает сообщение и сохраняет его во внутреннем массиве логов. Метод printLogs выводит все сохраненные логи в консоль. Метод clearLogs очищает массив логов.

```
function createLogger() {
  const logs = [];

  return {
    log: function (message) {
      logs.push(message);
    },
    printLogs: function () {
      logs.forEach(function (log, index) {
        console.log(`Log ${index + 1}: ${log}`);
      });
    },
    clearLogs: function () {
      logs.length = 0;
    }
  };
}

const logger = createLogger();
logger.log('Message 1');
logger.log('Message 2');
logger.printLogs(); // Выводит "Log 1: Message 1" и "Log 2: Message 2"
logger.clearLogs();
logger.printLogs(); // Ничего не выводит, так как логи были очищены
```

