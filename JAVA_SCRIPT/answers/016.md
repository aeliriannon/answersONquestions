Объясните, как this работает в JavaScript.
=====================

this - контекст вызова. Зависит от того, как и когда была вызвана функция.

* **Прямой вызов функции** (обычная функция) - this будет зависить от того, включен ли строгий режим (use strict).
    ** **Включен** - то this будет **undefined**
    ** **НЕ включен** - this будет ссылаться на глобальный объект **window**

* **Метод объекта** - this будет ссылаться на сам этот объект.(НО! если внутри метода будет вложенная обычная функция, то смотрите первый вариант(прямой вызов функции))

* **В конструкторах и классах** - this будет ссылаться на каждый новый экземпляр объекта.

* **Ручная привязка this** (call, apply, bind) - this будет ссылаться на тот объект к которому его привязали

* **Обработчики событий** - будет зависеть от того, какую функцию используют в качестве callback функции
    ** **обычная функция** - this  будет ссылаться на сам объект событий (event target)
    ** **стрелочная функция** -  т.к. не имеет своего контекста, то this будет
        - **строгий режим** - undefined
        - **БЕЗ строгого режима** - глобальный объект window

* **Стрелочные функции** - НЕ имеет своего контекста. Поэтому берет контекст у своего родителя.
    ** если она находится **внутри МЕТОДА объекта** - то контекст берет у этого метода, а т.к. контекст вызова у метода сам объект, то и для вложенной стрелочной функции будет тоже сам этот объект
    ** если она находится **внутри обычной функции**, то смотрим пунк первый - контекст для прямого вызова функции

### Обрати внимание!!!

* **Стрелочные функции:** В стрелочных функциях **(=>)** значение **this** определяется лексически, а не динамически. Они не имеют своего собственного значения **this** и используют значение **this** из окружающего контекста.
* **Вложенные функции:** Когда функция вызывается внутри другой функции, значение **this** внутренней функции будет отличаться от значения **this** во внешней функции. Во внутренней функции **this** будет ссылаться на глобальный объект (в строгом режиме - **undefined**), если он не определен иначе.
* **Callback функции:** Когда функция передается в качестве аргумента другой функции (как **callback**), значение **this** внутри **callback** функции может измениться в зависимости от контекста вызова. Это может привести к неожиданному поведению **this**, особенно если **callback** функция является методом объекта.
* **Методы объекта:** В методах объекта значение **this** ссылается на сам объект, к которому принадлежит метод. Однако, если метод вызывается без указания объекта (например, просто вызывается функция), **this** будет ссылаться на глобальный объект (в браузере - **window**).
* **Конструкторы:** Внутри конструктора **this** ссылается на новый экземпляр объекта, который создается с помощью оператора **new**. Конструкторы используются для создания новых объектов с определенными свойствами и методами.
* **Методы call() и apply():** Эти методы позволяют явно указать значение **this** при вызове функции. Метод **call()** принимает значение **this** как первый аргумент, а метод **apply()** принимает значение **this** в виде объекта и массива аргументов.

Примеры вопросов/задач
=====================

* Какое значение имеет this в глобальной области видимости?(**this имеет значение window или global в глобальной области видимости (зависит от окружения выполнения).**)
* Чем отличается this в обычных функциях от this в стрелочных функциях?(**В обычных функциях значение this зависит от того, как вызывается функция. В стрелочных функциях значение this заимствуется из окружающего лексического контекста.**)
* Каким значением будет this в методе объекта?(**В методе объекта значение this ссылается на сам объект, к которому принадлежит метод.**)
* Что будет значением this в callback функции, передаваемой в метод массива?(**Значение this в callback функции, передаваемой в метод массива, будет зависеть от контекста вызова метода. Если метод массива вызывается на самом массиве (например, arr.forEach(callback)), то this будет ссылаться на сам массив. Если же используется стрелочная функция в качестве callback, то значение this будет заимствовано из окружающего контекста.**)
* Что будет значением this в функции, вызываемой с помощью call() или apply()?(**Значение this в функции, вызываемой с помощью call() или apply(), определяется явно при вызове. Первый аргумент call() и apply() указывает значение this, которое будет использоваться в функции.**)


* Напишите функцию-конструктор Person, которая создает объекты с полями name и age. Добавьте метод getInfo, который выводит информацию о человеке, включая его имя и возраст, используя this.
```
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.getInfo = function() {
  console.log(`Name: ${this.name}, Age: ${this.age}`);
};

var person = new Person("John", 25);
person.getInfo(); // Output: Name: John, Age: 25
```
* Создайте объект car с методами start и stop, которые выводят сообщения о запуске и остановке автомобиля. При вызове методов, убедитесь, что this ссылается на объект car.
```
var car = {
  start: function() {
    console.log("Car started");
    console.log(this);
  },
  stop: function() {
    console.log("Car stopped");
    console.log(this);
  }
};

car.start(); // Output: Car started, {start: ƒ, stop: ƒ}
car.stop(); // Output: Car stopped, {start: ƒ, stop: ƒ}
```
* Реализуйте функцию calculateSum, которая принимает два числа и возвращает их сумму. Затем вызовите функцию с использованием call() и apply() для передачи аргументов и указания значения this.
```
function calculateSum(a, b) {
  return a + b;
}

var result = calculateSum.call(null, 5, 10);
console.log(result); // Output: 15

var args = [5, 10];
var result = calculateSum.apply(null, args);
console.log(result); // Output: 15
```
