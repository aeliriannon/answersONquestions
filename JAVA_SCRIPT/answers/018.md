В чем разница между Array.prototype.forEach и Array.prototype.map?
=====================

* forEach перебирает массив и **изменяет его**.
* .map() создает копию массива и **изменяет копию**.

Таким образом, если вам нужно выполнить операцию на каждом элементе массива без создания нового массива, используйте **forEach**. Если вы хотите преобразовать каждый элемент массива и получить новый массив с результатами преобразования, используйте **map**.

Примеры вопросов/задач
=====================

* В чем разница между методами forEach и map?(**Метод forEach выполняет переданную функцию для каждого элемента массива, но не возвращает новый массив. Метод map также выполняет функцию для каждого элемента массива, но создает новый массив, содержащий результаты вызова функции для каждого элемента.**)
* Какой результат возвращает метод forEach? А метод map?(**Метод forEach возвращает undefined, так как его основная цель - выполнить операции для каждого элемента массива, а не создать новый массив. Метод map возвращает новый массив, содержащий результаты вызова функции для каждого элемента исходного массива.**)
* Можно ли использовать метод forEach для создания нового массива? Почему?(**Нет, метод forEach нельзя использовать для создания нового массива, так как он не возвращает новый массив. Он предназначен для выполнения операций над каждым элементом массива.**)
* Какие операции можно выполнить с помощью forEach, но нельзя сделать с map?(**С помощью forEach можно изменять исходный массив напрямую, применяя различные операции к его элементам. Например, можно изменить значения элементов массива или выполнить какую-то побочную операцию для каждого элемента. map же не предназначен для изменения исходного массива, а только для создания нового массива на основе исходного.**)


* У вас есть массив чисел. Используя метод forEach, выведите на консоль каждый элемент массива, умноженный на 2.
```
const numbers = [1, 2, 3, 4, 5];
numbers.forEach((num) => {
  console.log(num * 2);
});
```
* У вас есть массив чисел. Используя метод map, создайте новый массив, содержащий каждый элемент исходного массива, возведенный в квадрат.
```
const numbers = [1, 2, 3, 4, 5];
const squaredNumbers = numbers.map((num) => {
  return num ** 2;
});
console.log(squaredNumbers);
```
* У вас есть массив строк. Используя метод forEach, выведите на консоль первую букву каждой строки. Затем, используя метод map, создайте новый массив, содержащий только первые буквы каждой строки.
```
const strings = ["apple", "banana", "cherry"];

// Используем forEach для вывода первой буквы каждой строки
strings.forEach((str) => {
  console.log(str[0]);
});

// Используем map для создания нового массива с первыми буквами
const firstLetters = strings.map((str) => {
  return str[0];
});

console.log(firstLetters);
```
* У вас есть большой массив чисел. Используя либо метод forEach, либо метод map, найдите сумму всех чисел в массиве. Сравните производительность обоих методов при работе с большими массивами.

const largeArray = [...Array(1000000)].fill(1); // Создаем большой массив из 1
```
// Используем forEach для вычисления суммы элементов массива
let sum = 0;
largeArray.forEach((num) => {
  sum += num;
});
console.log("Сумма (с использованием forEach):", sum);

// Используем reduce для вычисления суммы элементов массива
const sumReduce = largeArray.reduce((acc, num) => acc + num, 0);
console.log("Сумма (с использованием reduce):", sumReduce);
```
(**В данном примере мы создаем большой массив largeArray с 1 миллионом элементов, заполненных значением 1. Затем мы используем forEach и reduce для вычисления суммы всех элементов массива. С помощью forEach мы проходим по каждому элементу массива и добавляем его значение к переменной sum. В результате получаем сумму всех элементов. С помощью reduce мы передаем функцию-аккумулятор, которая складывает все элементы массива, начиная с начального значения 0. В результате получаем также сумму всех элементов. Оба подхода дают одинаковый результат, но использование reduce в данном случае более эффективно и компактно, так как он предназначен специально для выполнения агрегирующих операций над массивом.**)